#include "driver.hpp"

#include <queue>
#include <memory>
#include <cmath>

#include "decaying_particle_info.hpp"
#include "particle.hpp"


#undef DEBUG
#ifdef DEBUG
#include <iostream>
#endif

decaygen::driver::driver() {
}

decaygen::driver::~driver() {
}

std::vector<decaygen::particle_history> decaygen::driver::generate_decays(
    const decaygen::decaying_particle_info& parent_meson,
    decaygen::random_uniform_0_1_generator rng
    ) const {
  // no need to check this every time
  static const double speed_of_light = config.physical_params().speed_of_light;

  std::vector<particle_history> ret;
  std::queue<std::shared_ptr<decaygen::decaying_particle_info>> queue_to_decay;
  // create a copy as it may be modified
  queue_to_decay.push(std::make_shared<decaying_particle_info>(parent_meson));
  while(!queue_to_decay.empty()) {
    std::shared_ptr<decaying_particle_info> decpar = queue_to_decay.front();
    queue_to_decay.pop();
    
    auto find_particle = [this](int pdg) {
      auto p = particle_content.find(std::abs(pdg));
      if (p == particle_content.end()) {
        throw std::runtime_error("Undefined particle requested! PDG code "+std::to_string(pdg));
      }
      return p->second;
    };
    const particle& p = find_particle(decpar->pdg());
    auto const& dm = p.generate_decay_mode(rng);
    if(dm.is_null()) continue;

    // particle decay position hasn't been generated yet
    if(decpar->decay_position().t() < decpar->production_position().t()) {
      if(!decpar->is_pre_final_state() || config.use_unweighted_decays()) {
        const double tof = -p.lifetime() * std::log(1. - rng());
        decpar->set_decay_pos_from_tof(tof, speed_of_light);
      }
      else { // force the decay position into the detector
        const vector3& direction = decpar->production_momentum().vect().unit();
        const vector3& origin = decpar->production_position().vect();
        auto detector_points = geo.get_active_volume_intersections_for_beamline_vectors(origin, direction);
#ifdef DEBUG
        std::cout << p.pdg()
          << " " << origin.x() << ","<<origin.y()<<","<<origin.z()
          << " " << direction.x() << ","<<direction.y()<<","<<direction.z()<<" = "<<direction.mag()<<std::endl;
        std::cout << "detector points size: "<<detector_points.size()<<std::endl;
        if(detector_points.size() >= 1)
        {
          auto& v = detector_points.first();
          std::cout << "::1 -> "<<v.x()<<","<<v.y()<<","<<v.z()<<std::endl;
        }
        if(detector_points.size() >= 1)
        {
          auto& v = detector_points.last();
          std::cout << "::1 -> "<<v.x()<<","<<v.y()<<","<<v.z()<<std::endl;
        }
#endif
        if(detector_points.size() >= 2) {
          const double speed = decpar->production_momentum().beta() * speed_of_light;
          const double tof1 = (detector_points.first() - origin).mag()/speed;
          const double tof2 = (detector_points.last() - origin).mag()/speed;
          const double u = rng();
          // conversion between 0--1 to somewhere along tof1--tof2 with exponential decay
          const double tof = tof1 - p.lifetime() * std::log(1.-u+u*std::exp((tof1-tof2)/p.lifetime()));
          const double weight = std::exp(-tof1/p.lifetime()) - std::exp(-tof2/p.lifetime());
          decpar->set_decay_pos_from_tof(tof, speed_of_light);
          decpar->set_decay_weight(weight);
        }
        else {
          // particle doesn't decay inside detector - ignore decay
          continue; // while(!queue_to_decay.empty())
        }
      }
    }

    auto twobody_decay_momentum_in_com_frame = [](double parent_mass, double m1, double m2) -> double {
      return std::sqrt((parent_mass+m1+m2)*(parent_mass-m1-m2)*(parent_mass+m1-m2)*(parent_mass-m1+m2))/(2.*parent_mass);
    };
    if(dm.daughters.size() == 2) {
      auto const& d1 = find_particle(std::abs(dm.daughters[0].first));
      auto const& d2 = find_particle(std::abs(dm.daughters[1].first));
      const double m1 = d1.mass();
      const double m2 = d2.mass();
      const double cos_theta_cm = 1.-2.*rng();
      const double phi_cm = 2*M_PI*rng();
      const double decay_momentum = twobody_decay_momentum_in_com_frame(p.mass(), m1, m2);
      fourvector p1, p2;
      p1.set_mass_momentum_theta_phi(m1,decay_momentum,std::acos(cos_theta_cm),phi_cm);
      p2.set_mass_momentum_theta_phi(m2,-decay_momentum,std::acos(cos_theta_cm),phi_cm);
      p1.boost(decpar->decay_momentum().get_boost_vector());
      p2.boost(decpar->decay_momentum().get_boost_vector());
      std::shared_ptr<decaying_particle_info> info1(
          std::make_shared<decaying_particle_info>(dm.daughters[0].first,decpar,decpar->decay_position(),p1)
          );
      std::shared_ptr<decaying_particle_info> info2(
          std::make_shared<decaying_particle_info>(dm.daughters[1].first,decpar,decpar->decay_position(),p2)
          );
      if(dm.is_final_state() && geo.is_beamline_vector_in_active_volume(decpar->decay_position().vect())) {
        ret.push_back(particle_history{});
        particle_history& hist = ret.back();
        hist.add_final_state(info1);
        hist.add_final_state(info2);
      }
      else if(!dm.is_final_state()) {
        queue_to_decay.push(info1);
        queue_to_decay.push(info2);
      }
    }
    else if(dm.daughters.size() == 3) {
      auto const& d1 = find_particle(std::abs(dm.daughters[0].first));
      auto const& d2 = find_particle(std::abs(dm.daughters[1].first));
      auto const& d3 = find_particle(std::abs(dm.daughters[2].first));
      
      const double m1 = d1.mass();
      const double m2 = d2.mass();
      const double m3 = d3.mass();
      const double tcm = p.mass()-m1-m2-m3;

      const double decay_max_weight =
        twobody_decay_momentum_in_com_frame(tcm+m1,0,m1)
        * twobody_decay_momentum_in_com_frame(tcm+m1+m2,m1,m2);

      fourvector p1, p2, p3;
      while(true) {
        const double three_body_split = rng();
        const double m23 = m2 + m3 + three_body_split * tcm;
        
        const double decay_1_momentum = twobody_decay_momentum_in_com_frame(p.mass(),m23,m1);
        const double decay_23_momentum = twobody_decay_momentum_in_com_frame(m23,m2,m3);
        
        const double decay_weight = decay_1_momentum*decay_23_momentum;
        
        if(decay_weight < rng() * decay_max_weight) {
          continue; // while(true)
        }
        
        const double cos_theta_cm = 1.-2.*rng();
        const double phi_cm = 2*M_PI*rng();
        const double cos_theta_23 = 1.-2.*rng();
        const double phi_23 = 2*M_PI*rng();

        
        p1.set_mass_momentum_theta_phi(d1.mass(),decay_1_momentum,std::acos(cos_theta_cm),phi_cm);
        const fourvector p23 = fourvector{}.set_mass_momentum_theta_phi(m23,-decay_1_momentum,std::acos(cos_theta_cm),phi_cm);

        p2.set_mass_momentum_theta_phi(d2.mass(),decay_23_momentum,std::acos(cos_theta_23),phi_23);
        p3.set_mass_momentum_theta_phi(d3.mass(),-decay_23_momentum,std::acos(cos_theta_23),phi_23);
        p2.boost(p23.get_boost_vector());
        p3.boost(p23.get_boost_vector());

        if(dm.threebody_dalitz_reweighter.is_enabled()) {
          const double invmass2_12 = (p1+p2).m2();
          const double invmass2_13 = (p1+p3).m2();
          const double dalitz_weight = dm.threebody_dalitz_reweighter(invmass2_12,invmass2_13);
          if(config.use_unweighted_decays()) {
            if(dalitz_weight < rng() * dm.threebody_dalitz_reweighter.max_weight()) {
              continue; // while(true)
            }
          }
          else {
            const double dalitz_weight = dm.threebody_dalitz_reweighter(invmass2_12,invmass2_13);
            decpar->multiply_decay_weight(dalitz_weight);
          }
        }
        break;
      }

      p1.boost(decpar->decay_momentum().get_boost_vector());
      p2.boost(decpar->decay_momentum().get_boost_vector());
      p3.boost(decpar->decay_momentum().get_boost_vector());
      std::shared_ptr<decaying_particle_info> info1(
          std::make_shared<decaying_particle_info>(dm.daughters[0].first,decpar,decpar->decay_position(),p1)
          );
      std::shared_ptr<decaying_particle_info> info2(
          std::make_shared<decaying_particle_info>(dm.daughters[1].first,decpar,decpar->decay_position(),p2)
          );
      std::shared_ptr<decaying_particle_info> info3(
          std::make_shared<decaying_particle_info>(dm.daughters[2].first,decpar,decpar->decay_position(),p3)
          );

      if(dm.is_final_state() && geo.is_beamline_vector_in_active_volume(decpar->decay_position().vect())) {
        ret.push_back(particle_history{});
        particle_history& hist = ret.back();
        hist.add_final_state(info1);
        hist.add_final_state(info2);
        hist.add_final_state(info3);
      }
      else if(!dm.is_final_state()) {
        queue_to_decay.push(info1);
        queue_to_decay.push(info2);
        queue_to_decay.push(info3);
      }
    }
    else {
      throw std::runtime_error("4-body decays not implemented!");
    }

    if(dm.is_final_state() && geo.is_beamline_vector_in_active_volume(decpar->decay_position().vect())) {
      particle_history& history = ret.back();
      std::shared_ptr<decaying_particle_info> current = decpar;
      while(current) {
        history.prepend_particle(current);
        current = current->get_parent();
      }
    }
  }
  return ret;
}

decaygen::driver& decaygen::driver::add_particle_definition(const decaygen::particle& p) {
  particle_content[std::abs(p.pdg())] = p;
  return *this;
}

decaygen::driver& decaygen::driver::set_geometry(const decaygen::geometry& geom) {
  geo = geom;
  return *this;
}


decaygen::driver& decaygen::driver::set_particle_content(const std::map<particle_pdg, particle>& p) {
  particle_content = p;
  return *this;
}
decaygen::driver& decaygen::driver::set_particle_content(std::map<particle_pdg, particle>&& p) {
  particle_content = std::move(p);
  return *this;
}
